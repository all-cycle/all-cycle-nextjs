# All-Cycle
재활용이 용이한 제품을 구매할 수 있도록, 재활용에 대한 정보를 공유하는 플랫폼입니다

### **- 프로젝트 동기**
플라스틱 음료수 페트병 라벨 절취선이 들어가는 법이 적용되고 있는 흐름에 맞춰서 기업들이 책임감을 가지고 제품을 생산해내길 바라는 마음으로 기획하게 되었습니다.

### **- 프로젝트 목표**
초반 기획은 RN으로 개발하는 것이였으나, 음료수에 대한 정보와 웹 발행물에 대한 정보를 보여줘야한다고 기획을 했기 때문에 정적인 페이지가 많다고 판단하여서 `SSG (Static Site Generator)`를 이용하고 싶었습니다.
동적인 부분과 정적인 부분이 다양하게 섞이는 앱이 될 수 있도록 하기 위해서 NextJS 프레임워크를 선택하였습니다. 그래서 최대한 정적/동적 페이지를 분리하여 장점을 살리고자 하였습니다.

### **- 주요기능**
| 메인 | 제품검색 | 웹발행물 크롤링 | 마이페이지 & 퀴즈
| --- | --- | --- | --- |
| ![메인](./public/_readme_assets/allcycleCamera.gif) | ![제품검색](./public/_readme_assets/allcycleSearch.gif) | ![크롤링](./public/_readme_assets/allcycleLetter.gif) | ![마이페이지](./public/_readme_assets/allcycleMyPage.gif) |

<br/>

## __*KEYWORDS*__
### **`1) next/auth`**

처음에는 MERN stack 프로젝트를 진행할 때처럼 파이어베이스나 패스포트등을 이용하여 authentication을 구현해야겠다고 생각했었는데, NextJS는 자체 내에서 클라이언트와 서버를 한번에 관리할 수 있는 프레임워크이기 때문에 외부의 AuthO를 이용할 필요가 없다고 생각하였습니다. 

실제로 next/auth 기능을 사용해보니 MongoDB 내부에 User테이블 말고도 Cookie, Session, Token 테이블이 만들어졌습니다.

MongoDB를 연결하여 사용하게 되면 custom adaptor를 선언하여 auth 관리를 하게 되는데 그 테이블에 직접 접근을 하려면 새로운 mongoose.schema를 선언하여 이용해야 했습니다.

<br/>

### **`2) Incremental Static Generation & Crawling`**

서울환경연합에 크롤링에 대한 허락을 받은 후 본격적으로 크롤링을 시작하였습니다. 빌드시에 `Markdown`으로 문서화를 하면 Production Build에 가지고 있을 수 있고, Incremental Static Generation 기능을 이용하여 앞으로도 새로운 게시물이 들어왔을 경우에도 업데이트 된 자료를 보여줄 수 있도록 구현하였습니다.

<br/>

### **`3) Mixed Contents`**

Vercel 플랫폼에서 배포를 진행한 후 크롤링한 이미지의 url이 자동으로 `https` 로 변환되는 이슈가 생겼고,  크롤링한 사이트가 `https`를 지원하지 않았습니다.

최대한 Next.JS의 장점을 살리고 싶었기에 Static한 파일로 만들고자 하였습니다.빌드 시 로컬에 저장을 하기 때문에 속도가 더 빠르고, 관리자의 입장에서도 만들어진 페이지를 확인할 수 있어서 좋을 것이라 생각하였습니다.  
크롤링하는 이미지 또한 http인 url을 가지고 있었기 때문에 로컬에 저장해두는 것이 필요했습니다.  
`base64로 encoding`하여 로컬에 저장하는 방법은 문자열이 매우 길어져서 오히려 유저가 다운로드 받아야하는 페이지의 용량을 키운다는 생각이 들어 이미지 자체를 다운로드하는 라이브러리를 이용하였습니다.

그래서 기존에 Crawling을 페이지 자체에서 해서 보여줬다면 1분여의 시간이 걸리던 Letter 페이지의 로드 시간이 거의 체감하지 못할 정도로 단축되어 굉장히 감동적이였습니다.


<br />

### **- 회고**

Static하게 HTML을 만드는 것이 과연 얼마나 빠른 속도를 가져올 것인가에 대한 의문을 가지고 시작했던 프로젝트였습니다. 처음에 한페이지만을 크롤링 했을 때에는 느끼지 못했지만, 더 많은 양의 데이터를 다뤄보니 Static하게 빌드 된 HTML의 속도가 얼마나 빠른지, 체감할 수 있었습니다.  
기업에서 홈페이지를 항상 업데이트된 버전으로 관리하는 것이 얼마나 힘든지 알고있는 만큼, 정말 효율적인 도구이고 방법론이구나 라는 생각을 하게 되었습니다. 저는 SSR이나 외부 API를 많이 사용했기 때문에 디버깅이 많이 필요했는데 Vercel에서는 제대로 된 디버깅 툴이 지원되지 않아서 어려움이 있었던게 가장 아쉽습니다. 
